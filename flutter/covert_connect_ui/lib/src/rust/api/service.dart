// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'log.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'wrappers.dart';

// These functions are ignored because they are not marked as `pub`: `get_proxy`, `init_autostart`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProxyService>>
abstract class ProxyService implements RustOpaqueInterface {
  Future<void> addServer({required ServerConfig config});

  static Future<bool> checkDomain({required String domain}) => RustLib
      .instance
      .api
      .crateApiServiceProxyServiceCheckDomain(domain: domain);

  Future<void> deleteServer({required String host});

  Future<List<String>> getApps();

  static Future<bool> getAutostart() =>
      RustLib.instance.api.crateApiServiceProxyServiceGetAutostart();

  Future<ProxyConfig> getConfig();

  Future<List<String>> getDomains();

  static Future<List<LogLine>> getLog({BigInt? start, required BigInt limit}) =>
      RustLib.instance.api.crateApiServiceProxyServiceGetLog(
        start: start,
        limit: limit,
      );

  Future<int> getProxyPort();

  Future<ProxyState> getProxyState();

  Future<ProtocolConfig> getServerProtocol({
    required String server,
    required String key,
  });

  Future<ProxyStateFull> getState();

  Future<int> getTtfb({required String server, required String domain});

  static Future<void> log({required String message}) =>
      RustLib.instance.api.crateApiServiceProxyServiceLog(message: message);

  factory ProxyService() =>
      RustLib.instance.api.crateApiServiceProxyServiceNew();

  Future<void> removeApp({required String app});

  Future<void> removeDomain({required String domain});

  Future<void> setApp({required String app, required String serverHost});

  static Future<void> setAutostart({required bool enabled}) => RustLib
      .instance
      .api
      .crateApiServiceProxyServiceSetAutostart(enabled: enabled);

  Future<void> setDomain({required String domain, required String serverHost});

  Future<void> setProxyPort({required int port});

  Future<void> setProxyState({required ProxyState proxyState});

  Future<void> setServerEnabled({required String host, required bool value});

  Future<void> start({required ProxyConfig cfg});

  Future<void> stop();

  Future<void> updateServer({
    required String origHost,
    required ServerConfig newConfig,
  });
}

class ProxyConfig {
  final ProxyState state;
  final int port;
  final List<String> domains;
  final List<String> apps;
  final List<ServerConfig> servers;

  const ProxyConfig({
    required this.state,
    required this.port,
    required this.domains,
    required this.apps,
    required this.servers,
  });

  @override
  int get hashCode =>
      state.hashCode ^
      port.hashCode ^
      domains.hashCode ^
      apps.hashCode ^
      servers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyConfig &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          port == other.port &&
          domains == other.domains &&
          apps == other.apps &&
          servers == other.servers;
}

enum ProxyState { pac, all, off }

class ProxyStateFull {
  final bool initialized;
  final List<ServerInfo> servers;

  const ProxyStateFull({required this.initialized, required this.servers});

  @override
  int get hashCode => initialized.hashCode ^ servers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyStateFull &&
          runtimeType == other.runtimeType &&
          initialized == other.initialized &&
          servers == other.servers;
}

class ServerInfo {
  final ServerState state;
  final ServerConfig config;
  final String ip;
  final int port;

  const ServerInfo({
    required this.state,
    required this.config,
    required this.ip,
    required this.port,
  });

  @override
  int get hashCode =>
      state.hashCode ^ config.hashCode ^ ip.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerInfo &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          config == other.config &&
          ip == other.ip &&
          port == other.port;
}

class ServerState {
  final BigInt rxTotal;
  final BigInt txTotal;
  final BigInt errCount;
  final BigInt succesCount;

  const ServerState({
    required this.rxTotal,
    required this.txTotal,
    required this.errCount,
    required this.succesCount,
  });

  @override
  int get hashCode =>
      rxTotal.hashCode ^
      txTotal.hashCode ^
      errCount.hashCode ^
      succesCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServerState &&
          runtimeType == other.runtimeType &&
          rxTotal == other.rxTotal &&
          txTotal == other.txTotal &&
          errCount == other.errCount &&
          succesCount == other.succesCount;
}
